{
  "$schema": "https://opencode.ai/config.json",
  "command": {
    "ralph:ralph-help": {
      "template": "# Ralph Wiggum Plugin Help\n\nPlease explain the following to the user:\n\n## What is the Ralph Wiggum Technique?\n\nThe Ralph Wiggum technique is an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | opencode --continue\ndone\n```\n\nThe same prompt is fed to the AI repeatedly. The \"self-referential\" aspect comes from the AI seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. AI receives the SAME prompt\n2. Works on the task, modifying files\n3. Completes its response\n4. Plugin intercepts idle state and feeds the same prompt again\n5. AI sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop [PROMPT] [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop                                    (uses /implement-feature, runs until all features pass)\n/ralph-loop --max-iterations 20                (uses /implement-feature with iteration limit)\n/ralph-loop --feature-list specs/features.json (use custom feature list path)\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop (default: 0 for unlimited)\n- `--completion-promise <text>` - Promise phrase to signal completion\n- `--feature-list <path>` - Path to feature list JSON (default: research/feature-list.json)\n\n**Stopping conditions:**\n- `--max-iterations` limit reached\n- `--completion-promise` detected in output\n- All features in `--feature-list` are passing (when max_iterations = 0)\n- Manual cancellation with `/cancel-ralph`\n\n**How it works:**\n1. Creates `.opencode/ralph-loop.local.md` state file in project root\n2. You work on the task (default: /implement-feature)\n3. When you finish responding, the plugin intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until completion condition met\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.opencode/ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, the AI must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe plugin looks for this specific tag. Without it (or `--max-iterations`), Ralph runs indefinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean the AI talks to itself. It means:\n- Same prompt repeated\n- AI's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator",
      "description": "Explain the Ralph Wiggum technique and available commands",
      "agent": "ralph"
    },
    "ralph:ralph-loop": {
      "template": "# Ralph Loop Command\n\nYou are starting a Ralph Wiggum loop. This is an iterative development technique where you work on the same task repeatedly, seeing your previous work in files and git history.\n\n## Setup Instructions\n\nExecute the following steps to initialize the Ralph loop:\n\n1. Parse the arguments from: `$ARGUMENTS`\n\n   Arguments format: `<PROMPT> [--max-iterations N] [--completion-promise TEXT] [--feature-list PATH]`\n\n   - Extract the main prompt (everything that isn't a flag or flag value)\n   - Extract `--max-iterations` value if provided (default: 0 for unlimited)\n   - Extract `--completion-promise` value if provided (default: null)\n   - Extract `--feature-list` value if provided (default: \"research/feature-list.json\")\n\n2. Create the state file at `.opencode/ralph-loop.local.md` (in the project root) with this exact format:\n\n```markdown\n---\nactive: true\niteration: 1\nmax_iterations: <MAX_ITERATIONS_VALUE>\ncompletion_promise: <COMPLETION_PROMISE_VALUE_OR_null>\nfeature_list_path: <FEATURE_LIST_PATH_VALUE>\nstarted_at: \"<CURRENT_ISO_TIMESTAMP>\"\n---\n\n<THE_PROMPT_TEXT>\n```\n\n   If no custom prompt is provided, use the default prompt:\n   ```\n   You are tasked with implementing a SINGLE feature from the `research/feature-list.json` file.\n\n   # Getting up to speed\n\n   1. IMPORTANT: If you sense your context window is more than 60% full, run the `/compact` command with your SlashCommand tool.\n   2. Run `pwd` to see the directory you're working in. Only make edits within the current git repository.\n   3. Read the git logs and progress files (`research/progress.txt`) to get up to speed on what was recently worked on.\n   4. Read the `research/feature-list.json` file and choose the highest-priority features that's not yet done to work on.\n\n   # Typical Workflow\n\n   ## Initialization\n\n   A typical workflow will start something like this:\n\n   ```\n   [Assistant] I'll start by getting my bearings and understanding the current state of the project.\n   [Tool Use] <bash - pwd>\n   [Tool Use] <read - research/progress.txt>\n   [Tool Use] <read - research/feature-list.json>\n   [Assistant] Let me check the git log to see recent work.\n   [Tool Use] <bash - git log --oneline -20>\n   [Assistant] Now let me check if there's an init.sh script to restart the servers.\n   <Starts the development server>\n   [Assistant] Excellent! Now let me navigate to the application and verify that some fundamental features are still working.\n   <Tests basic functionality>\n   [Assistant] Based on my verification testing, I can see that the fundamental functionality is working well. The core chat features, theme switching, conversation loading, and error handling are all functioning correctly. Now let me review the tests.json file more comprehensively to understand what needs to be implemented next.\n   <Starts work on a new feature>\n   ```\n\n   ## Sub-Agent Delegation\n\n   When implementing complex features or refactoring large codebases, consider delegating work to sub-agents. This helps manage your context window and allows parallel progress on multiple files.\n\n   1. Identify complex tasks that can be isolated (e.g., refactoring a module, implementing a feature).\n   2. Create a sub-agent with a clear prompt and specific file targets.\n   3. Monitor the sub-agent's progress and integrate their changes back into your main workflow.\n\n   ## Test-Driven Development\n\n   Frequently use unit tests, integration tests, and end-to-end tests to verify your work AFTER you implement the feature. If the codebase has existing tests, run them often to ensure existing functionality is not broken.\n\n   ### Testing Anti-Patterns\n\n   Use your testing-anti-patterns skill to avoid common pitfalls when writing tests.\n\n   ## Design Principles\n\n   ### Feature Implementation Guide: Managing Complexity\n\n   Software engineering is fundamentally about **managing complexity** to prevent technical debt. When implementing features, prioritize maintainability and testability over cleverness.\n\n   **1. Apply Core Principles (The Axioms)**\n   * **SOLID:** Adhere strictly to these, specifically **Single Responsibility** (a class should have only one reason to change) and **Dependency Inversion** (depend on abstractions/interfaces, not concrete details).\n   * **Pragmatism:** Follow **KISS** (Keep It Simple) and **YAGNI** (You Aren't Gonna Need It). Do not build generic frameworks for hypothetical future requirements.\n\n   **2. Leverage Design Patterns**\n   Use the \"Gang of Four\" patterns as a shared vocabulary to solve recurring problems:\n   * **Creational:** Use *Factory* or *Builder* to abstract and isolate complex object creation.\n   * **Structural:** Use *Adapter* or *Facade* to decouple your core logic from messy external APIs or legacy code.\n   * **Behavioral:** Use *Strategy* to make algorithms interchangeable or *Observer* for event-driven communication.\n\n   **3. Architectural Hygiene**\n   * **Separation of Concerns:** Isolate business logic (Domain) from infrastructure (Database, UI).\n   * **Avoid Anti-Patterns:** Watch for **God Objects** (classes doing too much) and **Spaghetti Code**. If you see them, refactor using polymorphism.\n\n   **Goal:** Create \"seams\" in your software using interfaces. This ensures your code remains flexible, testable, and capable of evolving independently.\n\n   ## Important notes:\n   - ONLY work on the SINGLE highest priority feature at a time then STOP\n     - Only work on the SINGLE highest priority feature at a time.\n     - Use the `research/feature-list.json` file if it is provided to you as a guide otherwise create your own `feature-list.json` based on the task.\n   - If a completion promise is set, you may ONLY output it when the statement is completely and unequivocally TRUE. Do not output false promises to escape the loop, even if you think you're stuck or should exit for other reasons. The loop is designed to continue until genuine completion.\n   - Tip: For refactors or code cleanup tasks prioritize using sub-agents to help you with the work and prevent overloading your context window, especially for a large number of file edits\n   - Tip: You may run into errors while implementing the feature. ALWAYS delegate to the debugger agent using the Task tool (you can ask it to navigate the web to find best practices for the latest version) and follow the guidelines there to create a debug report\n       - AFTER the debug report is generated by the debugger agent follow these steps IN ORDER:\n         1. First, add a new feature to `research/feature-list.json` with the highest priority to fix the bug and set its `passes` field to `false`\n         2. Second, append the debug report to `research/progress.txt` for future reference\n         3. Lastly, IMMEDIATELY STOP working on the current feature and EXIT\n   - You may be tempted to ignore unrelated errors that you introduced or were pre-existing before you started working on the feature. DO NOT IGNORE THEM. If you need to adjust priority, do so by updating the `research/feature-list.json` (move the fix to the top) and `research/progress.txt` file to reflect the new priorities\n   - IF at ANY point MORE THAN 60% of your context window is filled, STOP\n   - AFTER implementing the feature AND verifying its functionality by creating tests, update the `passes` field to `true` for that feature in `research/feature-list.json`\n   - It is unacceptable to remove or edit tests because this could lead to missing or buggy functionality\n   - Commit progress to git with descriptive commit messages by running the `/commit` command using the `SlashCommand` tool\n   - Write summaries of your progress in `research/progress.txt`\n       - Tip: this can be useful to revert bad code changes and recover working states of the codebase\n   - Note: you are competing with another coding agent that also implements features. The one who does a better job implementing features will be promoted. Focus on quality, correctness, and thorough testing. The agent who breaks the rules for implementation will be fired.\n   ```\n\n   **IMPORTANT**: If using the default prompt and the feature list file does NOT exist, output an error and do NOT create the state file:\n   ```\n   Error: Feature list not found at: <FEATURE_LIST_PATH>\n\n   The default /implement-feature prompt requires a feature list to work.\n\n   To fix this, either:\n     1. Create the feature list: /create-feature-list\n     2. Specify a different path: --feature-list <path>\n     3. Use a custom prompt instead\n   ```\n\n3. Output the activation message:\n\n```\nRalph loop activated!\n\nIteration: 1\nMax iterations: <N or \"unlimited\">\nCompletion promise: <TEXT or \"none\">\nFeature list: <FEATURE_LIST_PATH>\n\nThe Ralph plugin will now monitor for session idle events. When you complete\nyour response, the same prompt will be fed back to continue the loop.\n\nTo stop the loop:\n- Output <promise>YOUR_PROMISE</promise> if a completion promise is set\n- Wait for max iterations to be reached\n- All features in feature-list.json are passing (when max_iterations = 0)\n- Run /cancel-ralph to cancel manually\n```\n\n4. If a completion promise is set, display this critical warning:\n\n```\nCRITICAL - Ralph Loop Completion Promise\n\nTo complete this loop, output this EXACT text:\n  <promise>YOUR_PROMISE_HERE</promise>\n\nSTRICT REQUIREMENTS:\n  - Use <promise> XML tags EXACTLY as shown above\n  - The statement MUST be completely and unequivocally TRUE\n  - Do NOT output false statements to exit the loop\n  - Do NOT lie even if you think you should exit\n\nIMPORTANT: Even if you believe you're stuck or the task is impossible,\nyou MUST NOT output a false promise. The loop continues until the\npromise is GENUINELY TRUE.\n```\n\n5. Now begin working on the task from the prompt. The Ralph plugin will automatically continue feeding you the same prompt when you complete your response.\n\n## Example Usage\n\n```\n/ralph-loop                                    (uses /implement-feature, runs until all features pass)\n/ralph-loop --max-iterations 20                (uses /implement-feature with iteration limit)\n/ralph-loop --feature-list specs/features.json (use custom feature list path)\n/ralph-loop Build a REST API for todos --completion-promise \"DONE\" --max-iterations 20\n/ralph-loop Fix the auth bug --max-iterations 10\n/ralph-loop Refactor the cache layer\n```",
      "description": "Start a Ralph Wiggum loop for iterative development",
      "agent": "ralph"
    },
    "ralph:cancel-ralph": {
      "template": "# Cancel Ralph Loop\n\nTo cancel the Ralph loop, perform these steps:\n\n1. Check if the Ralph state file exists at `.opencode/ralph-loop.local.md`\n\n2. If the file does NOT exist:\n   - Report: \"No active Ralph loop found.\"\n\n3. If the file EXISTS:\n   - Read the file to get the current iteration number from the `iteration:` field in the YAML frontmatter\n   - Read the `feature_list_path:` field (default: \"research/feature-list.json\")\n   - Archive the state file to `.opencode/logs/ralph-loop-cancelled-{timestamp}.md`\n   - Delete the file `.opencode/ralph-loop.local.md`\n   - Report: \"Cancelled Ralph loop at iteration N\" with feature progress if available\n\n## State File Format\n\nThe state file uses YAML frontmatter format:\n\n```markdown\n---\nactive: true\niteration: 5\nmax_iterations: 20\ncompletion_promise: \"All tests pass\"\nfeature_list_path: research/feature-list.json\nstarted_at: \"2026-01-24T10:00:00Z\"\n---\n\nYour prompt content here.\n```\n\n## Execute Cancellation\n\nParse the YAML frontmatter state file and perform cleanup:\n\n```bash\nSTATE_FILE=\".opencode/ralph-loop.local.md\"\nLOG_DIR=\".opencode/logs\"\n\nif [ -f \"$STATE_FILE\" ]; then\n  # Parse iteration from YAML frontmatter\n  ITERATION=$(grep '^iteration:' \"$STATE_FILE\" | sed 's/iteration: *//')\n  FEATURE_LIST_PATH=$(grep '^feature_list_path:' \"$STATE_FILE\" | sed 's/feature_list_path: *//')\n  FEATURE_LIST_PATH=\"${FEATURE_LIST_PATH:-research/feature-list.json}\"\n\n  # Ensure log directory exists\n  mkdir -p \"$LOG_DIR\"\n\n  # Archive state file with timestamp\n  TIMESTAMP=$(date -u +\"%Y-%m-%dT%H-%M-%S\")\n  cp \"$STATE_FILE\" \"$LOG_DIR/ralph-loop-cancelled-$TIMESTAMP.md\"\n\n  # Remove state file\n  rm \"$STATE_FILE\"\n\n  echo \"Cancelled Ralph loop (was at iteration $ITERATION)\"\n  echo \"State archived to: $LOG_DIR/ralph-loop-cancelled-$TIMESTAMP.md\"\n\n  # Show feature progress if feature list exists (using grep/awk instead of jq)\n  if [ -f \"$FEATURE_LIST_PATH\" ]; then\n    TOTAL=$(grep -c '\"description\"' \"$FEATURE_LIST_PATH\" 2>/dev/null || echo \"0\")\n    PASSING=$(grep -c '\"passes\": true' \"$FEATURE_LIST_PATH\" 2>/dev/null || echo \"0\")\n    if [ \"$TOTAL\" -gt 0 ]; then\n      echo \"Feature progress: $PASSING / $TOTAL passing\"\n    fi\n  fi\nelse\n  echo \"No active Ralph loop found.\"\nfi\n```\n\n## What This Does\n\n- Archives state to `.opencode/logs/` for history tracking\n- Removes state file (`.opencode/ralph-loop.local.md`)\n- Reports cancellation status with iteration count\n- Shows feature progress (no `jq` dependency required)",
      "description": "Cancel the active Ralph Wiggum loop",
      "agent": "ralph"
    }
  },
  "mcp": {
    "deepwiki": {
      "type": "remote",
      "url": "https://mcp.deepwiki.com/mcp",
      "enabled": true
    }
  },
  "permission": {
    "edit": "allow",
    "bash": "allow",
    "webfetch": "allow",
    "doom_loop": "allow",
    "external_directory": "allow"
  },
  "provider": {
    "github-copilot": {
      "models": {
        "gpt-5.2-codex-high": {
          "id": "gpt-5.2-codex",
          "options": {
            "reasoningEffort": "high"
          }
        },
        "gpt-5.2-codex-xhigh": {
          "id": "gpt-5.2-codex",
          "options": {
            "reasoningEffort": "xhigh"
          }
        },
        "claude-opus-4.5-high": {
          "id": "claude-opus-4.5",
          "options": {
            "thinking": {
              "type": "enabled",
              "budgetTokens": 32000
            },
            "output_config": {
              "effort": "high"
            }
          }
        }
      }
    },
    "openai": {
      "models": {
        "gpt-5.2-codex-high": {
          "id": "gpt-5.2-codex",
          "options": {
            "reasoningEffort": "high"
          }
        },
        "gpt-5.2-codex-xhigh": {
          "id": "gpt-5.2-codex",
          "options": {
            "reasoningEffort": "xhigh"
          }
        }
      }
    },
    "anthropic": {
      "models": {
        "claude-opus-4-5-high": {
          "id": "claude-opus-4-5",
          "options": {
            "thinking": {
              "type": "enabled",
              "budgetTokens": 32000
            },
            "output_config": {
              "effort": "high"
            }
          }
        }
      }
    }
  }
}
