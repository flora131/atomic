---
date: 2026-02-15 22:48:25 UTC
researcher: GitHub Copilot
git_commit: dbda8029862ba9e7bda5acce3a867a67d56cb048
branch: lavaman131/hotfix/sub-agents-ui
repository: atomic
topic: "Modify the /ralph loop so there isn't a automatic orchestration component and the main agent spawns worker sub-agents at will."
tags: [research, codebase, ralph, workflow, subagents]
status: complete
last_updated: 2026-02-15
last_updated_by: GitHub Copilot
---

# Research

## Research Question
Modify the `/ralph` loop so there isn't a automatic orchestration component and the main agent spawns worker sub-agents at will.

## Refined Research Question
Where is `/ralph`'s automatic orchestration wired today, and what existing codepaths already support direct, at-will worker sub-agent spawning from the main session?

## Summary
`/ralph` is currently hard-wired to invoke `runDAGOrchestrator()` for both fresh and resume flows, so orchestration is automatic once command parsing succeeds (`src/ui/commands/workflow-commands.ts:932-983`, `src/ui/commands/workflow-commands.ts:985-1022`).
The orchestrator itself owns scheduling, dispatch, retries, deadlock detection, and task persistence in one control loop (`src/ui/commands/workflow-commands.ts:236-413`).
Direct, non-orchestrated spawn patterns already exist elsewhere (command-level agent dispatch and one-off subagent calls), but they are not the `/ralph` execution path today (`src/ui/commands/agent-commands.ts:303-318`, `src/ui/chat.tsx:3578-3591`).

## Detailed Findings

### 1) `/ralph` currently auto-enters orchestrated mode
- `/ralph` args are parsed into `{ kind: "run" }` or `{ kind: "resume" }` in `parseRalphArgs` (`src/ui/commands/workflow-commands.ts:56-75`).
- Resume path validates session, normalizes interrupted tasks, then immediately calls `runDAGOrchestrator(context, parsed.sessionId)` (`src/ui/commands/workflow-commands.ts:959-981`).
- Fresh path performs decomposition (`streamAndWait` + `parseTasks`), writes `tasks.json`, then immediately calls `runDAGOrchestrator(context, sessionId)` (`src/ui/commands/workflow-commands.ts:1006-1020`).
- This means `/ralph` command execution always transitions into orchestrator-controlled worker dispatch once preconditions are met.

### 2) Automatic orchestration responsibilities are centralized in one loop
- `runDAGOrchestrator` performs repeated read/compute/dispatch/reconcile cycles (`src/ui/commands/workflow-commands.ts:262-412`).
- Ready-set selection is computed from task dependency state via `getReadyTasks()` (`src/ui/commands/workflow-commands.ts:276-281`, `src/ui/components/task-order.ts:301-340`).
- Deadlock diagnostics are produced with `detectDeadlock()` when no in-flight workers remain (`src/ui/commands/workflow-commands.ts:338-371`, `src/ui/components/task-order.ts:31-178`).
- Worker retries are tracked in-memory with `MAX_ATTEMPTS = 3`, with transitions from `in_progress` to `pending` (retry) or `error` (terminal) (`src/ui/commands/workflow-commands.ts:258-260`, `src/ui/commands/workflow-commands.ts:391-401`).

### 3) Worker spawning path used by `/ralph`
- Before spawn, selected tasks are persisted as `in_progress` (`src/ui/commands/workflow-commands.ts:287-297`).
- Worker prompts are generated by `buildWorkerAssignment(task, allTasks)` (`src/ui/commands/workflow-commands.ts:311`, `src/graph/nodes/ralph.ts:102-148`).
- Workers are spawned with `bridge.spawn({...})` and lifecycle events are bridged through `context.onSubagentBridgeEvent` (`src/ui/commands/workflow-commands.ts:320-333`).
- `SubagentGraphBridge.spawn()` creates an independent session, streams work, emits start/progress/complete events, and returns a structured `SubagentResult` (`src/graph/subagent-bridge.ts:149-274`).

### 4) Existing "spawn at will" patterns outside `/ralph`
- Agent commands already support direct dispatch by injecting instruction text into the main session: `Use the {agent} sub-agent to handle this task: ...` (`src/ui/commands/agent-commands.ts:313-315`).
- `CommandContext.spawnSubagent` also issues a direct sub-agent instruction and awaits one result via `streamCompletionResolverRef` (`src/ui/chat.tsx:3578-3591`).
- Graph-level one-off dispatch exists via `SubagentGraphBridge.spawn()` and `spawnParallel()` without invoking `/ralph` orchestrator logic (`src/graph/subagent-bridge.ts:149-304`).
- These patterns demonstrate direct sub-agent dispatch primitives are present, but `/ralph` command wiring currently routes through orchestration.

### 5) State persistence and UI are tied to the orchestrated flow
- Task persistence for `/ralph` is file-backed in session directories via `saveTasksToActiveSession()` and `readTasksFromDisk()` (`src/ui/commands/workflow-commands.ts:179-215`).
- UI task state is refreshed by directory watch on `tasks.json` (`src/ui/commands/workflow-commands.ts:1031-1050`).
- The bridge singleton used by orchestrator is initialized in chat startup when `createSubagentSession` is available (`src/ui/chat.tsx:2891-2904`).
- Worker prompt contract currently states workers receive assigned tasks from the orchestrator (`.claude/agents/worker.md:9`, `.claude/agents/worker.md:20`).

## Code References
- `src/ui/commands/workflow-commands.ts:56-75` - `/ralph` argument parsing into run/resume modes.
- `src/ui/commands/workflow-commands.ts:236-413` - `runDAGOrchestrator` control loop.
- `src/ui/commands/workflow-commands.ts:959-981` - Resume flow invokes orchestrator.
- `src/ui/commands/workflow-commands.ts:1006-1020` - Fresh flow invokes orchestrator.
- `src/ui/commands/workflow-commands.ts:179-215` - Task read/write helpers for session `tasks.json`.
- `src/ui/commands/workflow-commands.ts:1031-1050` - File watcher for `tasks.json`.
- `src/ui/components/task-order.ts:31-178` - Deadlock detection logic.
- `src/ui/components/task-order.ts:301-340` - Ready-task filtering logic.
- `src/graph/nodes/ralph.ts:102-148` - Worker assignment prompt builder.
- `src/graph/subagent-bridge.ts:149-274` - Single worker spawn lifecycle.
- `src/graph/subagent-bridge.ts:280-304` - Parallel worker spawn primitive.
- `src/ui/commands/agent-commands.ts:303-318` - Direct command-driven sub-agent dispatch.
- `src/ui/chat.tsx:3578-3591` - Direct sub-agent dispatch helper using stream wait.
- `src/ui/chat.tsx:2891-2904` - Subagent bridge initialization.
- `.claude/agents/worker.md:9-20` - Worker instructions expecting orchestrator-assigned task.

## Architecture Documentation
Current `/ralph` architecture is: command parse -> session/task bootstrap -> automatic orchestrator loop -> bridge-based worker spawn -> file-backed reconciliation.
The orchestration layer is not a separate service/module; it is an inline command-level control loop in `workflow-commands.ts`.
Direct sub-agent spawn primitives are shared platform capabilities, while `/ralph` currently applies an orchestration policy on top of those primitives.

## Historical Context (from research/)
- `research/docs/2026-02-15-ralph-dag-orchestration-implementation.md` - Documents the DAG orchestrator model and worker scheduling behavior.
- `research/docs/2026-02-15-ralph-dag-orchestration-blockedby.md` - Documents dependency enforcement and blockedBy execution behavior.
- `research/docs/2026-02-15-ralph-orchestrator-ui-cleanup.md` - Documents orchestrator-linked UI lifecycle and sub-agent event integration.
- `research/docs/2026-02-09-163-ralph-loop-enhancements.md` - Earlier loop architecture context and related evolution.
- `specs/ralph-dag-orchestration.md` - Specification context for orchestration control-loop design.
- `specs/ralph-loop-enhancements.md` - Specification context for broader `/ralph` loop behavior.

## Related Research
- `research/docs/2026-02-13-ralph-task-list-ui.md`
- `research/docs/qa-ralph-task-list-ui.md`

## Open Questions
- `/ralph` currently assumes orchestrator-managed dispatch in both run and resume branches; there is no alternate command path that bypasses `runDAGOrchestrator`.
- `CommandContext.spawnSubagent` uses a single stream completion resolver in chat context; this is relevant to how ad-hoc main-session spawning is currently coordinated (`src/ui/chat.tsx:3583-3594`).
