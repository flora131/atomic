---
date: 2026-02-22 20:00:40 UTC
researcher: Copilot
git_commit: 9e1bedf30c73bef721ce23426ee46a887216ae84
branch: lavaman131/hotfix/ralph-workflow
repository: ralph-workflow
topic: "Workflow UI Collapsible Phase Toggles & SDK Node Announcements"
tags: [research, codebase, workflow-sdk, opentui, collapsible-ui, phase-announcements, streaming-events]
status: complete
last_updated: 2026-02-22
last_updated_by: Copilot
---

# Research: Workflow UI Collapsible Phase Toggles & SDK Node Announcements

## Research Question

Research the current workflow SDK and UI implementation to understand:
1. How workflow nodes currently announce phase messages (e.g., `[Code Review] Review completed.`)
2. How to extend the workflow SDK so each node emits structured messages/events
3. How to add collapsible toggle sections to the UI — collapsed by default — that expand to show the full stream of events for each workflow phase

## Summary

The workflow SDK uses a **UI-layer pattern** for phase announcements: nodes execute in `src/graph/compiled.ts` and yield `StepResult` objects, but phase announcement text (e.g., `[Code Review] Review completed.`) is generated **after node completion** by a hardcoded `getPhaseSummary()` function in `src/ui/commands/workflow-commands.ts`. There is no event streaming from nodes to the UI during execution — only a single summary message after each node completes.

OpenTUI does **not** provide built-in collapsible/accordion components, but it provides sufficient primitives (mouse events, keyboard hooks, conditional rendering, flexbox layout) to implement custom collapsible sections. The codebase already has several collapsible patterns: `TaskListIndicator` (Ctrl+T toggle), `ToolResult` (immutable collapsed state), and `ParallelAgentsTree` (auto-collapse by status). A `useVerboseMode` hook exists but is only partially wired into the UI.

## Detailed Findings

### 1. Current Phase Announcement System

#### Phase Summary Generation (`src/ui/commands/workflow-commands.ts:558-580`)

Phase messages are generated by `getPhaseSummary()`, a function local to the Ralph workflow command:

```typescript
const getPhaseSummary = (
    nodeId: string,
    state: { tasks?: Array<{...}> },
): string | null => {
    if (nodeId === "taskDecomposition") return null;       // No announcement
    if (nodeId === "review") return "[Code Review] Review completed.";
    if (nodeId === "complete") return "[Workflow] Ralph workflow completed.";
    return null;
};
```

**Key observations:**
- Messages are **hardcoded strings** mapped to specific `nodeId` values
- No dynamic content (e.g., task counts, timing, agent names)
- `taskDecomposition` node returns `null` — the `[Task Decomposition] Decomposed into 6 tasks.` message referenced by the user does **not exist** in the current implementation
- No extensibility for custom workflows to define their own messages

#### Message Injection (`src/ui/commands/workflow-commands.ts:800-805`)

```typescript
const phaseSummary = getPhaseSummary(step.nodeId, { tasks });
if (phaseSummary) {
    context.addMessage("assistant", phaseSummary);
}
```

Phase messages are added as regular assistant messages via `context.addMessage()`. They render as standard `TextPart` objects with a `●` bullet prefix.

#### Alternative Phase Detection (`src/ui/utils/hidden-phase-summary.ts:1-16`)

A content-based fallback exists for classifying agent output:

```typescript
export function buildHiddenPhaseSummary(content: string): string | null {
  if (looksLikeTaskList) return null;
  if (looksLikeReview) return "[Code Review] Review completed.";
  return "[Workflow Phase] Completed.";
}
```

This is **not** used in the main Ralph workflow path — it's for content inspection when nodeId is unavailable.

### 2. Graph Execution & Event Flow

#### StepResult Emission (`src/graph/compiled.ts:469-474`)

The graph executor yields one `StepResult` per completed node:

```typescript
yield {
    nodeId: currentNodeId,
    state,
    result,
    status: isEndNode ? "completed" : "running",
};
```

#### ProgressEvent System (`src/graph/types.ts:346-357`)

A progress callback exists but is **not used for UI announcements**:

```typescript
export interface ProgressEvent<TState extends BaseState = BaseState> {
  type: "node_started" | "node_completed" | "node_error" | "checkpoint_saved";
  nodeId: NodeId;
  state: TState;
  timestamp: string;
}
```

Currently used only in `ralph.ts:530-544` to persist `tasks.json` after each node.

#### Signal System (`src/graph/types.ts:143-160`)

Signals (`human_input_required`, `checkpoint`, `context_window_warning`) are used for control flow, not UI messaging.

### 3. Current Workflow Node Definitions

The Ralph workflow (`src/graph/workflows/ralph.ts`) defines these nodes:

| Node ID | Type | Purpose |
|---------|------|---------|
| `taskDecomposition` | agent | Decompose spec into task list |
| `taskLoop` | taskLoop | Execute tasks via worker sub-agents |
| `review` | agent | Code review of implemented changes |
| `complete` | tool | Final cleanup and completion |

Nodes are created via factory functions in `src/graph/nodes.ts`:
- `agentNode()` — AI agent execution (lines 170-270)
- `toolNode()` — Custom tool functions (lines 369-437)
- `taskLoopNode()` — Task loop with sub-agent dispatch

Each node returns `NodeResult<TState>` with `stateUpdate`, optional `goto`, and optional `signals`. **No message/announcement field exists** in `NodeResult`.

### 4. UI Rendering Architecture

#### Parts-Based System

Messages are rendered via a parts-based system (`src/ui/parts/`):
- **Store** (`store.ts`): Binary search O(log n) insertion with timestamp-encoded IDs
- **Types** (`types.ts`): 8 part types: Text, Reasoning, Tool, Agent, TaskList, SkillLoad, McpSnapshot, Compaction
- **Handlers** (`handlers.ts`): Event handlers for part lifecycle

Phase announcement messages become `TextPart` objects rendered by `TextPartDisplay` (`src/ui/components/parts/text-part-display.tsx`).

#### Hidden Phase Content

The `hideStreamContentRef` mechanism accumulates streaming content without rendering it. When hidden content completes, a collapsed summary replaces it (e.g., `[collapsed] [Workflow Phase] Completed.`). This content is **not retrievable** after collapse — there is no expand mechanism.

### 5. Existing Collapsible Patterns

#### Pattern A: Parent-Controlled Toggle — TaskListIndicator (`src/ui/components/task-list-indicator.tsx:35-166`)

```typescript
export interface TaskListIndicatorProps {
    items: TaskItem[];
    maxVisible?: number;
    expanded?: boolean;  // Controlled by parent via Ctrl+T
}
```

- Parent holds `expanded` state, toggled via Ctrl+T keyboard shortcut
- Items sliced: `items.slice(0, maxVisible)`
- Overflow indicator: `▸ N more items`
- **No click handler** on indicator — keyboard-only toggle

#### Pattern B: Immutable Collapse — ToolResult (`src/ui/components/tool-result.tsx:97-180`)

```typescript
const [expanded] = useState(initialExpanded);  // Set once, never updated
```

- Collapsed state is set at mount and never changes
- Shows `▾ N more lines` but is NOT interactive
- Content sliced: `content.slice(0, maxCollapsedLines)`

#### Pattern C: Auto-Collapse — ParallelAgentsTree (`src/ui/components/parallel-agents-tree.tsx`)

- Auto-collapses when all agents complete
- Shows `(ctrl+o to expand)` hint at line ~562 but this **is not implemented**
- No actual keyboard binding for expanding completed agent trees

#### Pattern D: Verbose Mode — useVerboseMode (`src/ui/hooks/use-verbose-mode.ts`)

```typescript
export function useVerboseMode(initialValue = false): UseVerboseModeReturn {
    return { isVerbose, toggle, setVerboseMode, enable, disable };
}
```

- Designed for Ctrl+O toggle
- Controls ToolResult expansion, timestamp display, sub-agent tree expansion
- **Partially wired** — hook exists but not all components consume it

### 6. OpenTUI Capabilities for Collapsible Components

#### Available Primitives

From OpenTUI (`@opentui/core` v0.1.81, `@opentui/react` v0.1.81):

**Components**: `<box>`, `<text>`, `<code>`, `<markdown>`, `<scrollbox>`, `<input>`, `<textarea>`, `<select>`, `<tab-select>`, `<ascii-font>`
**No built-in**: collapsible, accordion, toggle, or expandable components

**Event Handlers** (`node_modules/@opentui/core/Renderable.d.ts:130-140`):
- Mouse: `onMouseDown`, `onMouseUp`, `onMouseMove`, `onMouseOver`, `onMouseOut`, `onMouseDrag`, `onMouseScroll`
- Keyboard: `useKeyboard()` hook with `KeyEvent` objects

**Current mouse usage**: Zero mouse click handlers in the codebase. All interactions are keyboard-driven.

**Layout**: Yoga flexbox engine with `flexDirection`, `justifyContent`, `alignItems`, dynamic visibility via conditional rendering or `visible` property.

**Rendering**: Double-buffered with cell-by-cell diffing, Zig-powered native rendering.

#### Building Collapsible Components

OpenTUI supports building custom collapsible components via:
1. React `useState` for toggle state
2. `onMouseDown` for click handling (or `useKeyboard()` for keyboard)
3. Conditional rendering: `{expanded && <box>...content...</box>}`
4. `<scrollbox>` for scrollable expanded content with fixed height

### 7. Icon System

Relevant icons from `src/ui/constants/icons.ts`:

```typescript
export const MISC = {
    collapsed: "▾",  // Down-pointing triangle (defined, used in ToolResult)
};
export const TASK = {
    active: "▸",     // Right-pointing triangle (used for overflow indicator)
};
export const STATUS = {
    active: "●",     // Black circle (used for phase announcements)
};
```

### 8. Workflow Session Management

Sessions are managed in `src/workflows/session.ts`:
- Session directory: `~/.atomic/workflows/sessions/{sessionId}/`
- Subdirectories: `checkpoints/`, `agents/`, `logs/`
- Metadata: `session.json` with status, node history, outputs

## Code References

### Phase Announcement System
- `src/ui/commands/workflow-commands.ts:558-580` — `getPhaseSummary()` function
- `src/ui/commands/workflow-commands.ts:800-805` — Phase message injection into chat
- `src/ui/utils/hidden-phase-summary.ts:1-16` — Content-based phase detection fallback

### Graph Execution
- `src/graph/compiled.ts:469-474` — StepResult yield after node completion
- `src/graph/compiled.ts:444-451` — ProgressEvent emission
- `src/graph/types.ts:346-357` — ProgressEvent interface
- `src/graph/types.ts:228-245` — NodeResult interface (no message field)
- `src/graph/types.ts:309-337` — NodeDefinition interface

### Ralph Workflow
- `src/graph/workflows/ralph.ts` — Workflow graph definition
- `src/graph/nodes/ralph.ts` — Prompt utilities and TaskItem type
- `src/graph/nodes/task-loop.ts` — Task loop node implementation

### Existing Collapsible Patterns
- `src/ui/components/task-list-indicator.tsx:35-166` — Ctrl+T expandable task list
- `src/ui/components/tool-result.tsx:97-180` — Immutable collapsed tool output
- `src/ui/components/parallel-agents-tree.tsx` — Auto-collapsing agent tree
- `src/ui/hooks/use-verbose-mode.ts` — Verbose mode toggle hook

### OpenTUI Integration
- `src/ui/chat.tsx:4357` — Global `useKeyboard()` handler
- `src/ui/theme.tsx` — Theme configuration with OpenTUI styles
- `src/ui/constants/icons.ts` — Icon constants including collapse indicators

### UI Parts System
- `src/ui/parts/store.ts` — Parts store (binary search, timestamp IDs)
- `src/ui/parts/types.ts` — Part type definitions (Text, Agent, Tool, etc.)
- `src/ui/parts/handlers.ts` — Part event handlers
- `src/ui/components/parts/text-part-display.tsx` — Text rendering (● prefix)
- `src/ui/components/parts/agent-part-display.tsx` — Agent display

## Architecture Documentation

### Current Workflow → UI Data Flow

```
1. Node Execution (src/graph/compiled.ts)
   └── Node.execute(context) → NodeResult<TState>
       └── yield StepResult { nodeId, state, result, status }

2. Workflow Command Consumer (src/ui/commands/workflow-commands.ts)
   └── for await (const step of executor.stream())
       ├── context.setTodoItems(tasks)          // Update task list
       ├── getPhaseSummary(step.nodeId, state)   // Generate announcement
       └── context.addMessage("assistant", msg)  // Add to chat

3. Chat Rendering (src/ui/chat.tsx)
   └── TextPartDisplay renders "● [Code Review] Review completed."
```

### Missing Capabilities for Collapsible Phases

1. **No per-phase event stream**: Nodes execute opaquely — streaming events (tool calls, agent output, progress) during a phase are not captured or associated with the phase.
2. **No phase metadata on messages**: Phase messages are plain text with no metadata linking them to a workflow phase or node.
3. **No expand/collapse state per phase**: The UI has no concept of "phase sections" — phase announcements are just messages in the chat flow.
4. **No event accumulator**: Hidden phase content is discarded after collapse — cannot be re-expanded.

### Available Building Blocks

1. **ProgressEvent system** (`types.ts:346-357`) — Already emits `node_started`/`node_completed` events; could be extended for streaming
2. **Parts system** (`src/ui/parts/`) — Supports ordered, typed message parts with streaming appends
3. **useVerboseMode hook** — Existing toggle infrastructure (partially wired)
4. **OpenTUI mouse events** — Click handlers available but unused
5. **Existing collapse icons** — `▾` (collapsed), `▸` (expand), `●` (active) defined in icons.ts
6. **TaskListIndicator pattern** — Working model for parent-controlled expand/collapse

## Historical Context (from research/)

### Workflow SDK Design
- `research/docs/2026-02-11-workflow-sdk-implementation.md` — Workflow SDK implementation details
- `research/docs/2026-02-15-ralph-dag-orchestration-implementation.md` — Ralph DAG orchestration
- `research/docs/2026-02-05-pluggable-workflows-sdk-design.md` — Pluggable workflows SDK design
- `specs/workflow-sdk-implementation.md` — Workflow SDK spec with custom tools, sub-agents, and graph execution

### UI Architecture
- `research/docs/2026-02-16-opentui-rendering-architecture.md` — OpenTUI rendering architecture
- `research/docs/2026-02-15-ui-inline-streaming-vs-pinned-elements.md` — UI inline streaming vs pinned elements
- `research/docs/2026-02-16-chat-system-design-ui-research.md` — Chat system design research
- `specs/chat-system-parts-based-rendering.md` — Parts-based rendering spec
- `specs/ui-inline-streaming-vs-pinned-elements.md` — UI inline streaming design

### OpenTUI
- `research/docs/2026-02-22-opentui-collapsible-components-research.md` — OpenTUI collapsible components (online research)
- `research/docs/2026-02-22-opentui-collapsible-components-analysis.md` — OpenTUI collapsible capabilities analysis
- `research/docs/2026-01-31-opentui-library-research.md` — Foundational OpenTUI research
- `research/docs/2026-02-16-opentui-deepwiki-research.md` — OpenTUI DeepWiki research

### Ralph Task List UI
- `research/docs/2026-02-13-ralph-task-list-ui.md` — Ralph task list UI research
- `specs/ralph-task-list-ui.md` — Ralph persistent task list UI spec

### Frontend Design
- `research/docs/2026-02-14-frontend-design-builtin-skill-integration.md` — Frontend design skill integration
- `specs/frontend-design-builtin-skill-integration.md` — Frontend design spec

## Related Research

- `specs/ralph-dag-orchestration.md` — Ralph DAG orchestration technical design
- `specs/sdk-ui-standardization.md` — SDK UI standardization spec
- `specs/tui-layout-streaming-content-ordering.md` — TUI layout streaming content ordering
- `research/docs/2026-02-15-subagent-event-flow-diagram.md` — Subagent event flow

## Open Questions

1. **Event granularity**: What events should be captured per phase? (tool calls, text chunks, agent spawns, errors?)
2. **Phase identification**: Should phases be identified by nodeId, or should nodes declare phase metadata (name, icon, description)?
3. **Streaming during execution**: Should phase toggles show live streaming events during node execution, or only after node completion?
4. **Persistence**: Should expanded/collapsed state persist across re-renders or session restarts?
5. **Interaction model**: Should toggles be keyboard-driven (Ctrl+O/Ctrl+T pattern), mouse-clickable, or both?
6. **Event buffer limits**: How many events to buffer per phase before truncating?
7. **NodeResult extension**: Should `NodeResult` be extended with a `message?: string` field for per-node announcements, or should this remain in the UI layer?
